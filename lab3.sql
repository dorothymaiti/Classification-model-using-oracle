-- Lab Exercise 1 – Analyzing data
-- Use the statistical function to answer the following question, using the EMPT, DEPT, etc tables.

-- 1-1 – What is the maximum and minimum salary
select max(sal), min(sal) from emp;

-- 1-2 – What is the difference between the maximum and the average salary
select max(sal), floor(avg(sal)), floor(max(sal) - avg(sal)) as diff from emp;

-- 1-3 – Count the number of employees per grade
select grade, count(*)
  from salgrade
 inner join emp on emp.sal >= losal and emp.sal <= hisal
 group by grade;

-- 1-4 – What is the average salary per department
select dept.deptno, floor(avg(sal))
  from dept
 inner join emp on emp.deptno = dept.deptno
 group by dept.deptno;

-- 1-5 – Select the department and number of employees,  who have a department count greater than 2
select dept.deptno, count(*)
  from dept
 inner join emp on emp.deptno = dept.deptno
 group by dept.deptno
having count(*) > 2;

-- 1-6 – List the employees who have a salary greater than the average salary
select ename, sal 
 from emp
 where sal > (select avg(sal) from emp);

-- 1-7- Use the SUMMARY package to gather statistics
set serveroutput on
declare
   s DBMS_STAT_FUNCS.SummaryType;
begin
   DBMS_STAT_FUNCS.SUMMARY('scueva', 'emp', 'sal', 3, s);
   dbms_output.put_line('SUMMARY STATISTICS');
   dbms_output.put_line('Count  : '||s.count);
   dbms_output.put_line('Min    : '||s.min);
   dbms_output.put_line('Max    : '||s.max);
   dbms_output.put_line('Range  : '||s.range);
   dbms_output.put_line('Mean   : '||round(s.mean));
   dbms_output.put_line('Mode Count : '||s.cmode.count);
   dbms_output.put_line('Mode        : '||s.cmode(1));
   dbms_output.put_line('Variance    : '||round(s.variance));
   dbms_output.put_line('Stddev      : '||round(s.stddev));
   dbms_output.put_line('Quantile 5  : '||s.quantile_5);
   dbms_output.put_line('Quantile 25 : '||s.quantile_25);
   dbms_output.put_line('Median      : '||s.median);
   dbms_output.put_line('Quantile 75 : '||s.quantile_75);
   dbms_output.put_line('Quantile 95 : '||s.quantile_95);
   dbms_output.put_line('Extreme Count : '||s.extreme_values.count);
   dbms_output.put_line('Top 5 : '||s.top_5_values(1)||','||
                                                s.top_5_values(2)||','||
                                                s.top_5_values(3)||','||
                                                s.top_5_values(4)||','||
                                                s.top_5_values(5));
   dbms_output.put_line('Bottom 5 : '||s.bottom_5_values(5)||','||
                                                     s.bottom_5_values(4)||','||
                                                     s.bottom_5_values(3)||','||
                                                     s.bottom_5_values(2)||','||
                                                     s.bottom_5_values(1));
end;
/

-- 1-8- Take the SQL stats functions used in the above exercises and modify them to include the HAVING Clause.
-- 1-9- You will need to think carefully on How and Why you are using the HAVING clause in each case.
-- 1-10- What are you trying to show or demonstrate in each case.

-- Lab Exercise 2 – Analytical SQL Functions
-- This lab exercise requires you to practice using some of the hundreds of analytical SQL functions. In addition to the 
-- exercises/tasks listed below, you should spend some time exploring and experimenting with the many of these analytical SQL 
-- functions


-- Task 1 – Sampling data
-- For one of your larger tables, containing the largest number of records, compare the results and records generated by using 
-- the SAMPLE and ORA_HASH functions, for the following sample sizes.

CREATE TABLE bigtable (id NUMBER, weight NUMBER, adate DATE);

INSERT INTO bigtable (id, weight, adate)
SELECT MOD(ROWNUM,1000), DBMS_RANDOM.RANDOM, SYSDATE-1000+DBMS_RANDOM.VALUE(0,1000) FROM all_objects
/

select count(*) from bigtable;              -- 18765

select count(*) from bigtable sample(5);    -- 856
select count(*) from bigtable sample(10);   -- 1967
select count(*) from bigtable sample(15);   -- 2856
select count(*) from bigtable sample(20);   -- 3775

SELECT count(*) FROM bigtable
 WHERE ORA_HASH(id,(select count(*) from bigtable),12345) < (select count(*) from bigtable) * (5 / 100); -- 899
SELECT count(*) FROM bigtable
 WHERE ORA_HASH(id,(select count(*) from bigtable),12345) < (select count(*) from bigtable) * (10 / 100); -- 1779
SELECT count(*) FROM bigtable
 WHERE ORA_HASH(id,(select count(*) from bigtable),12345) < (select count(*) from bigtable) * (15 / 100); -- 2734
SELECT count(*) FROM bigtable
 WHERE ORA_HASH(id,(select count(*) from bigtable),12345) < (select count(*) from bigtable) * (20 / 100); -- 3694

-- What differences can you find and/or observations that you see. Can you explain these?
-- SAMPLE is a random value around the percentage, but ORA_HASH is a random valeu under the percentage

-- Task 2 – PIVOT
-- Write a query that returns the average salary per department (full name)
select min(dept.dname) name, round(avg(sal)) average
  from emp
 inner join dept on dept.deptno = emp.deptno
 group by emp.deptno;

-- Rewirte the query using the PIVOT command to display the display the departments as columns in the output.
SELECT * FROM
(
  select dept.dname, emp.sal from emp
   inner join dept on dept.deptno = emp.deptno
)
PIVOT 
(
  avg(sal)
  FOR dname IN ('SALES', 'RESEARCH', 'ACCOUNTING')
)

-- Task 3 – LEAD and LAG
-- Write a query that returns some of the details of each employee, ordered by salary in ascending order
select ename, job, sal from emp order by sal asc;

-- Alter the query to add an additional column that displays the salary of the previous person in the results set
select ename, job, sal, LAG(sal, 1, -1) OVER (ORDER BY sal) AS sal_prev
  from emp order by sal asc;

-- Alter the query to add an additional column that displays the salary of the next person in the results set
select ename, job, sal, LEAD(sal, 1, -1) OVER (ORDER BY sal) AS sal_next
  from emp order by sal asc;

-- Add the following columns
--* Difference in salary between the employee and the person who earns just below them
--* Difference in salary between the employee and the person who earns just more than them
select ename, job, sal, 
       sal - LAG(sal, 1, sal) OVER (ORDER BY sal) AS diff_prev,
       LEAD(sal, 1, sal) OVER (ORDER BY sal) - sal AS diff_next
  from emp order by sal asc;

-- Task 4 – Ranking Staff
-- Using your basic query that returns the details of employees and their salary
-- * Use the RANK function applied to all the data
-- * Use the PERCENT_RANK function applied to all the data
-- * Use the CUME_DIST function applied to all the data
select ename, job, sal,
       RANK() OVER (ORDER BY sal) sal_rank,
       ROUND(PERCENT_RANK() OVER (ORDER BY sal), 2) sal_percentrank,
       ROUND(CUME_DIST() OVER (ORDER BY sal), 2) sal_cumedist
  from emp
 order by sal asc;

-- Using the PARTITION BY clause change the above queries to rank the results based on each department.
select ename, job, sal,
       RANK() OVER (ORDER BY sal) sal_rank,
       ROUND(PERCENT_RANK() OVER (ORDER BY sal), 2) sal_percentrank,
       ROUND(CUME_DIST() OVER (ORDER BY sal), 2) sal_cumedist,
       COUNT(empno) OVER (PARTITION BY deptno) DEPT_COUNT
  from emp
 order by sal asc;









